## Giới thiệu
Các hệ thống peer-to-peer và ứng dụng là các hệ thống phân tán mà không có sự kiểm soát tập trung hoặc tổ chức theo phân cấp, trong đó mỗi node chạy phần mềm với chức năng tương đương. xem lại các tính năng của các ứng dụng peer-to-peer gần đây mang lại một danh sách dài: lưu trữ dự phòng, sự lâu dài, lựa chọn các máy chủ kế bên, ẩn danh, tìm kiếm, xác thực và đặt tên theo cấp bậc. mặc dù có nhiều tính năng phong phú, hoạt động cốt lõi trong hầu hết các hệ thống peer-to-peer là vị trí hiệu quả của các mục dữ liệu.  sự đóng góp của bài báo là **một giao thức có khả năng mở rộng cho việc tìm kiếm trong một hệ thống peer-to-peer năng động với các node tham gia và rời đi thường xuyên**.     
Giao thức Chord chỉ hỗ trợ một hoạt động: đưa ra một key, nó ánh xạ tới key lên mỗi node. Tuỳ thuộc vào ứng dụng sử dụng chord, node đó có thể có trách nhiệm lưu trữ một giá trị được liên kết với key. Chord sử dụng hàm băm đồng nhất để gán các key tới các node Chord. Hàm băm đồng nhất có xu hướng cân bằng tải, từ đó mỗi node nhận được khoảng cùng số lượng key, và yêu cầu tương đối ít sự di chuyển các key khi các node tham gia và rời khỏi hệ thống.     
Công việc trước đây về việc băm đồng nhất giả sử rằng mỗi node biết được gần hết các node khác trong hệ thống, một cách tiếp cận mà không mở rộng với số lượng lớn các node. ngược lại, mỗi node Chord chỉ cần định tuyến thông tin về một vài node khác. Bởi bảng định tuyến đã được phân tán, một node chord truyền thông với các node khác để thực hiện tra cứu.    
Trong trạng thái ổn định, một hệ thống N-Node, mỗi node giữ thông tin về O(log N) node khác, và giả quyết tất cả các tra cứu thông qua O(log N) thông điệp tới các node khác. Chord duy trì thông tin định tuyến khi các node tham gia và rời khỏi hệ thống. một node chord yêu cầu thông tin về O(log N) node khác để định tuyến hiệu quả, nhưng hiệu suất giảm bớt đáng kể khi thông tin đó đã lỗi thời. điều này quan trọng trong thực tế vì các node sẽ tham gia và rời khỏi một cách tuỳ ý, và sự nhất quán của O(log N) trạng thái có thể khó duy trì. chỉ một mẩu thông tin trên một node cần được sửa chữa để Chord đảm bảo chính xác định tuyến của các câu truy vấn.  Chord có một thuật toán đơn giản để duy trì thông tin này trong một môi trường linh động.    
## mô hình hệ thống
Chord đơn giản hoá việc thiết kế hệ thống peer-to-peer và các ứng dụng dựa trên nó bằng cách giải quyết những vấn đề khó khăn này:      
- **cân bằng tải**: Chord hoạt động như một như một hàm băm phân tán, phân bố đều các khoá trên các node, điều này cung cấp một mức độ cân bằng tải tự nhiên.
- **sự phân quyền**: Chord được phân tán hoàn toàn, không node nào quan trọng hơn node nào. điều này cải thiện tính mạnh mẽ và làm cho Chord thích hợp cho  ứng dụng Peer-to-peer được tổ chức lỏng lẻo.
 - **khả năng mở rộng**: chi phí của một tra cứu Chord tăng lên theo số lượng node. Vì vậy thậm chí các hệ thống lớn là khả thi. không có điều chỉnh tham số được yêu cầu để đạt được tỉ lệ này.   
 - **tính khả dụng**: chord tự động điều chỉnh các bảng nội bộ của nó để phản ánh các node mới tham gia cũng như các node bị lỗi, đảm bảm rằng trừ các lỗi chính trong mạng bên dưới, node chứa một khoá có thể luôn được tìm thấy. điều này đúng ngay cả khi hệ thống đang ở trong một trạng thái liên tục thay đổi.
- **tính linh hoạt**: Chord không ràng buộc về cấu trúc của các key mà nó tìm kiếm: không gian khoá Chord là  bằng phẳng. điều này cho phép ứng dụng một số lượng lớn sự linh hoạt trong cách họ ánh xạ tên của họ tới các key.   

Phần mềm Chord có khuôn dạng của một thư viện để liên kế với các ứng dụng sử dụng nó. ứng dụng tương tác với Chord theo hai cách chính:
- thứ nhất: thư viện chord cung cấp một chức năng *lookup(key)* mang lại địa chỉ IP của node chứ key đó.     
- thứ hai: phần mềm chord trên mỗi node thông báo việc áp dụng các thay đổi trong bộ các key mà node chứa nó. điều này cho phép phần mềm ứng dụng, ví dụ: di chuyển các giá trị tương ứng tới nơi mới của chúng khi một node mới tham gia.    

Việc ứng dụng chord là đáng tin cậy cho cung cấp bất kỳ yêu cầu xác thực, bộ nhớ đệm, nhân rộng, và thân thiện với người sử dụng đặt tên dữ liệu. không gian khoá phẳng của Chord làm giảm việc thực hiện các tính năng này. ví dụ: mộ ứng dụng có thể xác thực dữ liệu bằng cách lưu trữ nó dưới một khoá được bắt nguồn từ một mật mã băm của dữ liệu. tương tự, một ứng dụng có thể nhân bản dữ liệu bằng cách lưu trữ nó dưới hai khoá riêng biệt bắt nguồn từ việc nhận dạng mức ứng dụng của dữ liệu.     
<img src="../image/fig1.png" >
 [fig1.jpg](../fig1.png)   <br>
 Hình trên là cấu trúc của một loại ứng dụng.
 - **Layer cao nhất** thực hiện chức năng đặc biệt như hệ thống tập tin siêu dữ liệu .
 - **Lớp tiếp theo** thực hiện một bảng băm phân tán  mục đích chung mà nhiều ứng dụng sử dụng để chèn và  lấy các khối dữ liệu được nhận diện với các khoá duy nhất. bảng băm phân tán sẽ lưu trữ và nhân bản các khối. Bảng băm phân tán sử dụng Chord để xác định node chịu trách nhiệm cho việc lưu trữ một khối. và sau đó truyền thông với máy chủ lưu trữ khối trên node đó để đọc hoặc ghi khối.  


## Giao thức Chord
phần này mô tả giao thức Chord. ***giao thức Chord xác định cách tìm ra vị trí của các key, cách các node mới tham gia hệ thống và cách khôi phục từ lỗi của các node hiện có***. Trong bài báo này giả sử rằng môi trường truyền thông ở trong mạng lưới cơ bản mà cả hai đối xứng ( nếu A có thể định tuyến tới B, thì B có thể định tuyến tới A) và chuyển tiếp( nếu A có thể định tuyến tới B và B -> C, thì A có thể địng tuyến tới C).
###  **A. Tổng quan**
Chord cung cấp tính toán phân tán nhanh của một hàm băm ánh xạ các key tới các node của nó. CHord gán các key với các node thông qua hàm băm nhất quán, có một số đặc tính mong muốn. với xác suất cao hàm băm cân bằng tải (tất cả các node nhận được cùng số lượng key). ngoài ra với xác suất cao, khi một node thứ N tham gia (hoặc rời khỏi) mạng lưới, chỉ một phần O(1/N) của các key được chuyển đến một vị trí khác - đây rõ ràng là mức tối thiểu cần thiết để duy trì một cân bằng tải.   
Chord cải thiện khả năng mở rộng của hàm băm nhất quán bằng cách tránh yêu cầu một node biết về mọi node khác. một node chỉ cần một số lượng nhỏ thông tin định tuyến về các node khác. Bởi vì thông tin này được Phân phối, một node giải quyết chức năng băm bằng cách truyền thông với các node khác. trong một mạng lưới N node, mỗi node duy trì thông tin về O(log N) node khác, và một tra cứu yêu cầu O(log N) thông điệp.   
###  **B. Hàm băm nhất quán (Consistent Hashing)**
Hàm băm nhất quán gán mỗi node và key định danh m bit sử dụng SHA-1 như là một hàm băm cơ sở. định danh của một node được chọn bằng cách băm địa chỉ IP của node, trong khi một định danh key được tạo ra bằng cách băm key. chúng ta sẽ sử dụng thuật ngữ 'key' để chỉ cả hai khoá gốc và hình ảnh của nó dưới chức năng băm. tương tự, thuật ngữ 'node' sẽ ám chỉ node và định danh của nó dưới chức năng băm. chiều dài định danh m phải đủ lớn để làm cho xác suất của hai node hoặc hai key băm cho cùng một định danh gần như giống nhau.     
Băm nhất quán gán các key tới các node như sau: các định danh được đặt trên một vòng tròn module 2<sup>m</sup>. khoá k được gán cho node đầu tiên, node mà được so sánh bằng hoặc theo sau k trong không gian nhận định. node này được gọi là node kế tiếp node k (ký hiệu là **successor(k)**). Nếu những định danh được biểu diễn dưới dạng một vòng tròn các số từ 0 đến 2m-1, thì successor(k) là node đầu tiên theo chiều kim đồng hồ từ k.   
![fig2.jpg](../fig2.png) <br>
Figure 2 cho thấy một vòng Chord với m=6. vòng Chord có 10 node và lưu trữ 5 key. node kế tiếp của định danh 10 là node 14, vì vậy key 10 nên được đặt tại node 14. tương tự key 24 và 30 nên được đặt tại node 32, key 38 tại node 38 và key 54 tại node 56.    
băm nhất quán được thiết kế để cho phép các node vào và ra khỏi mạng với sự gián đoạn là tối thiểu. để duy trì băm nhất quán ánh ánh xạ khi một node n tham gia vào mạng, chắc chắn các key trước được gán cho node kế tiếp của n bây giờ trở thành gán cho n. khi node n rời khỏi mạng. tất cả các key được gán cho no sẽ được gán lại cho node kế tiếp của n. không có thay đổi nào trong việc gán các key tới các node cần xảy ra. Trong ví dụ trên, nếu một node đã được tham gia với địng danh là 26, nó sẽ nắm bắt khoá với định danh 24 từ node với định danh là 32.  
kết quả dưới đây đã đượcchứng minh trong các bài báo giới thiệu về băm nhất quán: 
    Đối với mọi tập N node và K key, với xác suất cao: 
    1. mỗi node chịu trách nhiệm cho nhiều nhất (1+ t)K/N keys.
    2. khi một node thứ N + 1 tham gia hoặc rời khỏi mạng, trách nhiệm cho O(K/N) keys thay đổi được chuyển giao.  
khi hàm băm nhất quán được thực thi với mô tả bên trên, định lý chứng minh một ràng buộc của t= O(LOG n). Bài báo về băm nhất quán cho thấy t có thể giảm xuống một hằng số nhỏ tuỳ ý bằng cách mỗi node chạy Ω(Log N) node ảo, với mỗi định danh của chính nó. trong phần còn lại chúng ta sẽ phân tích tất cả các giới hạn về công việc trên một node ảo. như vậy nếu mỗi node thực chạy v các node ảo, tất cả các giới hạn phải được nhân bởi v.  
Cụm từ "với xác suất cao" được thảo luận. một giải thích đơn giản là các node và key được lựa chọn ngẫu nhiên, có thể hợp lý trong một mô hình không đối địch của thế giới. sự phân bố xác suất sau đó là sự lựa chọn ngẫu nhiên các keys và nodes. và nói rằng mooitj sự lựa chọn ngẫu nhiên như vậy có lẽ không tạo ra một sự phân bố không công bằng. một mô hình tương tự đã được áp dụng để phân tích hàm băm chuẩn. hàm băm chuẩn phân phối dữ liệu một cách hợp lý khi tập hợp các khoá được băm là ngẫu nhiên. khi các keys không là ngẫu nhiên, như vậy, một kết quả không được đảm bảo thực sự, đối với bất kỳ hàm băm nào, tồn tại một số key được phân phối rất tệ bởi hàm băm và  trong thực tế, điều đó là không thể xảy ra. chúng ta có thể chọn một hàm băm một cách ngẫu nhiên để các keys được phân phối hợp lý với xác suất cao hơn sự lựa chọn của hàm băm. một kỹ thuật tương tự có thể áp dụng cho băm nhất quán, do đó yêu cầu xác nhận"xác suất cao"  trong định lý trên. Thay vì chọn một hàm băm ngẫu nhiên, chúng ta sử dụng hàm băm SHA-1 được mong đợi có tính phân bố tốt.   
tất nhiên khi hàm băm ngẫu nhiên đã được chọn, một kẻ thù có thể chọn một tập hợp các keys phân phối tồi cho hàm băm đó. trong ứng dụng của chúng tôi, kẻ thù có thể tạo ra một tập các key lớn và chèn vào vòng ring chỉ có các keys đó mà ánh xạ tới một node cụ thể. do đó việc tạo ra một tập các keys được phân phối tồi. Như với hàm băm chuẩn, tuy nhiên, chúng tôi hy vọng rằng một sự không đối nghịch của các keys có thể được phân tích như thể nó là ngẫu nhiên. việc sử dụng giả định này, chúng ta đưa ra nhiều kết quả dưới đây như kết quả "xác suất cao".   
### **C. Simple Key Location**
phần này mô tả một thuật toán Chord đơn giản nhưng mà chậm. phần tiếp theo mô tả làm thế nào để mở rộng thuật toán cơ bản để tăng hiệu quả, và làm thế nào để duy trì sự chính xác của thông tin định tuyến của chord. các tra cứu  có thể được thực thi trên một ring chord với trạng thái của mỗi node. . mỗi node chỉ cần biết cách liên lạc với nút kế tiếp hiện tại trên vòng tròn. Truy vấn cho một định danh có thể theo vòng tròn qua các điểm kế tiếp cho đến khi chúng gặp được node mong muốn. thứ hai trong cặp là node truy vấn ánh xạ tới.   
Figure3(a) chỉ ra mã giả thực hiện tra cứu key đơn giản. các lời gọi từ xa và các biến tham chiếu được tới trước  bởi định danh của node cục bộ, trong khi biến tham chiếu cục bộ và các phương thức gọi bỏ qua node cục bộ. do đó n.foo() dùng để chỉ một lời gọi từ xa của phương thứ `foo`  trên node n, trong khi n.bar. không có dâu ngoặc đơn, là một RPC để phân tích n từ node n. ký hiệu (a,b] biểu thị cho đoạn của Chord ring bằng cách di chuyển theo chiều kim đồng hồ từ a (không chứa a) đến b (bao gồm cả b).   
Figure3(b) chỉ ta một ví dụ trong đó node 8 thực hiện một tìm kiếm key 54. node 8 gợi ý tìm node kế tiếp cho key 54 mà cuối cùng trả về node kế tiếp của key đó, node 56. Truy vấn thăm mọi node trên ring giữa node 8 và 56. kết quả trả về  theo chiều ngược của con đường tiếp theo bởi truy vấn.     
![fig3.jpg](../fig3.png)       <br>
### **D. Scalable key location**
Sơ đồ tra cứu đã trình bày trong phần trước sử dụng một số thông điệp trong số lượng các node. để tăng tốc tra cứu, Chord duy trì bổ sung thông tin định tuyến . thông tin bổ sung này không phải là điều cần thiết cho sự chính xác, mà được thực hiện miễn là mỗi node biết chính xác node kế tiếp của nó.   
Như trước đây, để m là số bit trong các định danh key/node. Mỗi node n duy trì một bảng định tuyến lên tới m mục( thực tế là O(log n) riêng biệt ), được gọi là bảng định tuyến (figure table). Mục thứ i trong bảng tại node n chứa định danh của node s với s=successor(n + 2<sup>i-1</sup>), trong đó 1<= i<= m. chúng ta gọi node s là finger thứ i của node n, và biểu diễn bằng n.finger[i] (trong Table I hình bên dưới) . Một finger table bao gồm định danh Chord và địa chỉ IP(và số cổng) của node liên quan.chú ý rằng finger đầu tiên của node n là node kế tiếp của n trên vòng tròn.   
![fig5.jpg](../fig5.png)     <br>
![fig4.jpg](../fig4.png)       <br>
Ví dụ ở Figure4(a) cho thấy bảng finger table của node 8. finger đầu tiên của node 8 là node 14, khi node 14 là node đầu tiên kế  tiếp (8 + 2<sup>0</sup>) mod 2<sup>6</sup>=9 . tương tự, finger cuối cùng của node 8 là node 42,  khi node 42 là node đầu tiên của kế tiếp (8 + 2<sup>5</sup>) mod 2<sup>6</sup> =40.   
Sự sắp xếp có hai đặc điểm quan trọng: 
    - mỗi node chỉ lưu thông tin của một số lượng lượng node khác, và biết nhiều hơn về các node gần theo sau nó trên vòng tròn hơn là các node xa hơn.
    - bảng finger table của một node thường thường không chứa đầy đủ thông tin để trực tiếp xác định node kế tiếp của một key tuỳ ý. ví dụ: node 8 trong Fingure 4(a) không thể xác địng node kế tiếp của key 34, vì node kế tiếp (node 38) này không xuất hiện trong finger table của node 8.     
![fig6.jpg](../fig6.png)     <br>
Figure 5 cho thấy mã giả của phương thức _find-successor_ đã được mở rộng để sử dụng trong **finger table** . Nếu *id* ở giữa n và successor của nó, *find_successor* kết thúc và node n trả về successor của nó. Nếu không, n tìm kiếm trên *finger table* của nó node n' với ID gần nhất đứng trước *id*, và sau đó gọi *find_successor* tại n'.   
Ví dụ: xem xét vòng tròn Chord trong hình Figure 4(b), và giả sử node 8 muốn tìm *successor* của key 54. khi đó finger lớn nhất của 8 đứng trước 54 là node 42, node 8 sẽ yêu câu node 42 để giải quyết. Ngược lại, node 42 sẽ xác định finger lớn nhất trong bảng *finger table* của nó đứng trước 54, tức là node 51. Cuối cùng, node 51 sẽ tìm ra node kế tiếp của nó, node 56, kế tiếp key 54, và do đó sẽ trả về node 56 cho node 8.   
định ký IV.2: với xác suất cao, số lượng các node phải được liên hệ để tìm một *successor* trong N node mạng là O(log N).   
### **E. Dynamic Operation and Failures - các hoạt động và lỗi** 
trong thực tế, Chord cần đối phó với các node tham gia hệ thống và với các node Lỗi hoặc tự ý rời khỏi. phần này mô tả cách Chord xử lý các tình huống này.   
#### **E.1 các node tham gia và sự ổn định. **
Để đảm bảo các tra cứu thực thi chính xác khi các node tham gia  thay đổi. Chord phải đảm bảo rằng mỗi con trỏ kế tiếp của node được cập nhật. nó thực hiện bằng cách sử dụng giao thức **stabilization** mà mỗi node chạy theo định kỳ trong bối cảnh và cập nhật các *finger table* của Chord và các con trỏ Successor.   
![fig7.jpg](../fig7.png)    <br>
Figure 6 cho thấy mã giả cho các joins và stabilixation. khi node n đầu tiên bắt đầu, nó gọi n.join(n'), trong đó n' là bất kỳ node nào được biết đến , hoặc n.create() để tạo một mạng Chord mới. hàm join() yêu cầu n' tìm kiếm trực tiếp *successor* của n.    
Mỗi node chạy stabilize() theo định kỳ để tìm hiểu về các node vừa mới tham gia. Mỗi lần node n chạy *stabilize()*, nó yêu cầu successor của nó đưa predecessor p của successor, và quyết định xem p nên là node kế tiếp của n hay không. đây sẽ là trường hợp nếu node p gần đây đã tham gia vào hệ thống. ngoài ra, stabilize() thông báo sự cho successor của n về sự tồn tại  của n. Cho successor cơ hội để thay đổi predecessor của nó đến n. successor chỉ làm điều này nếu nó biết không có predecessor nào gần hơn n.     
Định kỳ một node gọi *fix_fingers* để đảm bảo các bảng table là chính xác. đây là cách các node mới khởi tạo các *finger table* của chúng, và đó là cách các node hiện có kết hợp các node mới vào các finger table của chúng. mỗi node cũng chạy *check_predecessor* theo định kỳ, để xoá con trỏ *predecessor* của node nếu n.predecessor đã lỗi. điều này cho phép nó chấp nhận một *predecessor* mới trong *notify*.      
Một ví dụ đơn giản, giả sử node n tham gia hệ thống, và ID của nó nằm ở giữa node n<sub>p</sub> và n<sub>s</sub>, việc nó gọi join(), n thu được n<sub>s</sub> là successor của nó. Node n<sub>s</sub>khi được thông báo bởi n, thu được n là predecessor của n<sub>s</sub>. khi n<sub>p</sub> tiếp theochayj stabilize(), nó yêu cầu n<sub>s</sub> đưa ra predecessor của nó, n<sub>p</sub> khi đó thu được n là successor. Cuối cùng,  n<sub>p</sub> thông báo cho n, và n thu được n<sub>p</sub> là predecessor của n. tại thời điểm này , tất cả con trỏ precessor và successor là chính xác. Tại mỗi bước trong tiến trình, n<sub>s</sub> có thể được truy cập từ n<sub>p</sub> sử dụng con trỏ successor, điều này có nghĩa rằng **tra cứu** đồng thời với **tham gia** là không bị gián đoạn. Figure 7 minh hoạ cách thức tham gia, khi ID của n là 26, và các ID của n<sub>s</sub>,tương ứng n<sub>p</sub> là 21 và 32.   
Ngay khi các con trỏ successor là chính xác, các cuộc gọi tới *find_successor()* sẽ phản ánh node mới. việc các node tham gia mới đây mà vẫn chưa được phản ánh trong các bảng của các node khác có thể dẫn đến *find_successor()* bước đầu không đạt, nhưng vòng lặp trong thuật toán tra cứu sẽ vẫn tiếp tục các con trỏ kế tiếp qua các node mới tham gia cho đến khi prodecessor được đưa ra chính xác. Cuối cùng sửa fingers() sẽ điều chỉnh các mục finger table.   
Định lý 3: nếu bất kỳ các hoạt động tham gia tuần tự được thực thi xen kẽ với sự ổn định, khi đó tại khoảng thời gian cuối cùng tham gia các con trỏ kế tiếp sẽ hình thành một vòng tròn trên tất cả các node trong mạng. Nói cách khác, sau một khoảng thời gian, mỗi node có thể đưa ra bất kỳ node khác trong mạng bởi các con trỏ tiếp theo.   
Chương trình làm việc ổn định của chúng tôi đảm bảo thêm các node tới một vòng chord theo cách giữ khả năng kết nối của các node hiện có. Ngay cả khi đối mặt đồng thời việc tham gia và mất đi và sắp xếp lại các thông điệp. Giao thức ổn định này sẽ không được sửa chữa trong một hệ thống Chord mà đã chia ra thành nhiều vòng không liên tục, hoặc một vòng đơn lặp lại nhiều lần xung quanh không gian định danh. Những trường hợp vô lý này không thể được tạo ra bởi bất kỳ chuỗi của các node tham gia. nếu được tạo ra,  các trường hợp này có thể phát hiện và sửa sửa bằng cách lấy mẫu định kỳ của cấu trúc vòng.





